#!/usr/bin/env python3
"""
PCA and t-SNE visualization of motion embeddings exported from Rust.

This script analyzes embeddings generated by the Rust motion_embedding library,
providing variance analysis and visualizations to assess embedding quality.

Now includes FFT vs DCT comparison analysis.

Usage:
    # First, generate embeddings from Rust:
    cargo test --test export_embeddings -- --ignored --nocapture

    # Then analyze:
    poetry run python analyze_embeddings.py embeddings.json
    poetry run python analyze_embeddings.py embeddings.json -o output_dir/
"""

import argparse
import json
import sys
from pathlib import Path
from typing import Optional

import matplotlib.pyplot as plt
import numpy as np
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE


def load_embeddings(path: str) -> tuple[np.ndarray, np.ndarray, list[str], list[str], list[str]]:
    """Load embeddings from JSON file exported by Rust.

    Expected format (from Rust export_embeddings test):
    {
        "embeddings": [
            {"compact": [24 floats], "full": [24+spectral floats], "label": "helix_0",
             "trajectory_type": "helix", "spectral_transform": "FFT", ...},
            ...
        ],
        "config": {...}
    }

    Returns:
        compact: np.ndarray of shape (n_samples, 24) - compact embedding
        full: np.ndarray of shape (n_samples, 24+k*8) - full embedding with spectral
        labels: list of string labels
        types: list of trajectory type strings
        transforms: list of spectral transform strings ("FFT" or "DCT")
    """
    with open(path) as f:
        data = json.load(f)

    compact = np.array([e['compact'] for e in data['embeddings']])
    # Full embedding includes spectral features - may vary in size, pad if needed
    full_list = [e.get('full', e['compact']) for e in data['embeddings']]
    max_len = max(len(f) for f in full_list)
    full = np.array([f + [0.0] * (max_len - len(f)) for f in full_list])

    labels = [e.get('label', f'sample_{i}') for i, e in enumerate(data['embeddings'])]
    types = [e.get('trajectory_type', 'unknown') for e in data['embeddings']]
    transforms = [e.get('spectral_transform', 'FFT') for e in data['embeddings']]

    return compact, full, labels, types, transforms


def analyze_variance(embeddings: np.ndarray) -> dict:
    """Compute variance statistics matching Rust validation module.

    Health targets:
    - PC1 variance < 40% (balanced distribution)
    - Effective dimensionality > 8 (most features contribute)
    - Max/min feature group variance ratio < 50
    """
    pca = PCA()
    pca.fit(embeddings)

    pc1_var = pca.explained_variance_ratio_[0] * 100

    # Effective dimensionality via entropy
    ratios = pca.explained_variance_ratio_
    ratios = ratios[ratios > 1e-10]
    entropy = -np.sum(ratios * np.log(ratios))
    effective_dim = np.exp(entropy)

    # Feature group variances (matching Rust indices)
    feature_vars = np.var(embeddings, axis=0, ddof=1)

    group_variances = {
        'scale': feature_vars[0],
        'shape': np.sum(feature_vars[1:4]),
        'momentum': np.sum(feature_vars[4:10]),
        'heading': np.sum(feature_vars[10:13]),
        'maneuver': np.sum(feature_vars[13:16]),
        'velocity': np.sum(feature_vars[16:19]),
        'chirality': feature_vars[19],
        'g_force': np.sum(feature_vars[20:23]),
        'smoothness': feature_vars[23],
    }

    # Variance ratio
    non_zero = [v for v in group_variances.values() if v > 1e-10]
    variance_ratio = max(non_zero) / min(non_zero) if len(non_zero) >= 2 else float('inf')

    is_healthy = (pc1_var < 40.0 and
                  effective_dim > 8.0 and
                  variance_ratio < 50.0)

    return {
        'pc1_variance_percent': pc1_var,
        'effective_dimensionality': effective_dim,
        'total_dimensions': 24,
        'eigenvalue_spectrum': pca.explained_variance_[:10].tolist(),
        'explained_variance_ratio': pca.explained_variance_ratio_.tolist(),
        'feature_group_variances': group_variances,
        'variance_ratio_max_min': variance_ratio,
        'is_healthy': is_healthy,
    }


def get_type_colors(types: list[str]) -> tuple[np.ndarray, dict]:
    """Convert trajectory types to numeric labels for coloring."""
    unique_types = sorted(set(types))
    type_to_idx = {t: i for i, t in enumerate(unique_types)}
    colors = np.array([type_to_idx[t] for t in types])
    return colors, type_to_idx


def plot_pca(embeddings: np.ndarray, types: list[str],
             output_path: str = 'pca_3d.png'):
    """3D PCA scatter plot colored by trajectory type."""
    pca = PCA(n_components=3)
    proj = pca.fit_transform(embeddings)

    colors, type_to_idx = get_type_colors(types)
    unique_types = list(type_to_idx.keys())

    fig = plt.figure(figsize=(14, 10))
    ax = fig.add_subplot(111, projection='3d')

    for i, ttype in enumerate(unique_types):
        mask = np.array(types) == ttype
        ax.scatter(proj[mask, 0], proj[mask, 1], proj[mask, 2],
                  label=ttype, alpha=0.7, s=60, edgecolors='white', linewidth=0.3)

    ax.set_xlabel(f'PC1 ({pca.explained_variance_ratio_[0]*100:.1f}%)')
    ax.set_ylabel(f'PC2 ({pca.explained_variance_ratio_[1]*100:.1f}%)')
    ax.set_zlabel(f'PC3 ({pca.explained_variance_ratio_[2]*100:.1f}%)')
    ax.set_title('Motion Embedding PCA by Trajectory Type (3D)')
    ax.legend(loc='upper left', bbox_to_anchor=(1.05, 1), fontsize=8, framealpha=0.9)
    plt.tight_layout()
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved: {output_path}")


def plot_tsne(embeddings: np.ndarray, types: list[str],
              perplexity: int = 30, output_path: str = 'tsne_3d.png'):
    """3D t-SNE scatter plot colored by trajectory type."""
    # Adjust perplexity for small datasets
    n_samples = embeddings.shape[0]
    perplexity = min(perplexity, max(5, n_samples // 3))

    tsne = TSNE(n_components=3, perplexity=perplexity, random_state=42,
                max_iter=1000, init='pca')
    proj = tsne.fit_transform(embeddings)

    colors, type_to_idx = get_type_colors(types)
    unique_types = list(type_to_idx.keys())

    fig = plt.figure(figsize=(14, 10))
    ax = fig.add_subplot(111, projection='3d')

    for i, ttype in enumerate(unique_types):
        mask = np.array(types) == ttype
        ax.scatter(proj[mask, 0], proj[mask, 1], proj[mask, 2],
                  label=ttype, alpha=0.7, s=60, edgecolors='white', linewidth=0.3)

    ax.set_xlabel('t-SNE 1')
    ax.set_ylabel('t-SNE 2')
    ax.set_zlabel('t-SNE 3')
    ax.set_title(f'Motion Embedding t-SNE (3D, perplexity={perplexity})')
    ax.legend(loc='upper left', bbox_to_anchor=(1.05, 1), fontsize=8, framealpha=0.9)
    plt.tight_layout()
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved: {output_path}")


def plot_feature_distributions(embeddings: np.ndarray, output_path: str = 'feature_dist.png'):
    """Box plots of feature distributions by group."""
    feature_groups = {
        'Scale': [0],
        'Shape': [1, 2, 3],
        'Momentum': [4, 5, 6, 7, 8, 9],
        'Heading': [10, 11, 12],
        'Maneuver': [13, 14, 15],
        'Velocity': [16, 17, 18],
        'Chirality': [19],
        'G-Force': [20, 21, 22],
        'Smoothness': [23],
    }

    fig, axes = plt.subplots(3, 3, figsize=(14, 10))
    axes = axes.flatten()

    for ax, (name, indices) in zip(axes, feature_groups.items()):
        data = embeddings[:, indices]
        ax.boxplot(data, tick_labels=[f'D{i}' for i in indices])
        ax.set_title(name)
        ax.axhline(y=0, color='r', linestyle='--', alpha=0.3)
        ax.axhline(y=1, color='gray', linestyle=':', alpha=0.3)
        ax.axhline(y=-1, color='gray', linestyle=':', alpha=0.3)
        ax.set_ylim(-1.5, 1.5)
        ax.grid(True, alpha=0.3)

    plt.suptitle('Feature Group Distributions (target range: [-1, 1])', fontsize=14)
    plt.tight_layout()
    plt.savefig(output_path, dpi=150)
    plt.close()
    print(f"Saved: {output_path}")


def plot_feature_by_type(embeddings: np.ndarray, types: list[str],
                         output_path: str = 'feature_by_type.png'):
    """Heatmap of mean feature values by trajectory type."""
    unique_types = sorted(set(types))
    n_types = len(unique_types)

    # Compute mean embedding for each type
    mean_embeddings = np.zeros((n_types, 24))
    for i, ttype in enumerate(unique_types):
        mask = np.array(types) == ttype
        mean_embeddings[i] = embeddings[mask].mean(axis=0)

    # Feature group labels
    feature_labels = (
        ['scale'] +
        [f'shape_{i}' for i in range(3)] +
        [f'mom_{i}' for i in range(6)] +
        [f'head_{i}' for i in range(3)] +
        [f'man_{i}' for i in range(3)] +
        [f'vel_{i}' for i in range(3)] +
        ['chiral'] +
        [f'gf_{i}' for i in range(3)] +
        ['smooth']
    )

    plt.figure(figsize=(16, 8))
    im = plt.imshow(mean_embeddings, cmap='RdBu_r', vmin=-1, vmax=1, aspect='auto')
    plt.colorbar(im, label='Mean Feature Value')

    plt.yticks(range(n_types), unique_types)
    plt.xticks(range(24), feature_labels, rotation=45, ha='right')

    # Add group separators
    group_boundaries = [1, 4, 10, 13, 16, 19, 20, 23]
    for b in group_boundaries:
        plt.axvline(x=b-0.5, color='black', linewidth=0.5)

    plt.title('Mean Feature Values by Trajectory Type')
    plt.xlabel('Feature')
    plt.ylabel('Trajectory Type')
    plt.tight_layout()
    plt.savefig(output_path, dpi=150)
    plt.close()
    print(f"Saved: {output_path}")


def plot_correlation_matrix(embeddings: np.ndarray, output_path: str = 'correlation.png'):
    """Correlation matrix heatmap."""
    corr = np.corrcoef(embeddings.T)

    plt.figure(figsize=(12, 10))
    im = plt.imshow(corr, cmap='RdBu_r', vmin=-1, vmax=1)
    plt.colorbar(im, label='Correlation')

    # Add group separators
    group_boundaries = [0, 1, 4, 10, 13, 16, 19, 20, 23, 24]
    for b in group_boundaries[1:-1]:
        plt.axhline(y=b-0.5, color='black', linewidth=0.5)
        plt.axvline(x=b-0.5, color='black', linewidth=0.5)

    plt.title('Feature Correlation Matrix')
    plt.xlabel('Dimension')
    plt.ylabel('Dimension')
    plt.tight_layout()
    plt.savefig(output_path, dpi=150)
    plt.close()
    print(f"Saved: {output_path}")


def plot_eigenvalue_spectrum(embeddings: np.ndarray, output_path: str = 'eigenspectrum.png'):
    """Eigenvalue spectrum (scree plot)."""
    pca = PCA()
    pca.fit(embeddings)

    n_components = len(pca.explained_variance_ratio_)
    cumsum = np.cumsum(pca.explained_variance_ratio_) * 100

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

    # Scree plot
    ax1.bar(range(1, n_components + 1), pca.explained_variance_ratio_ * 100,
            alpha=0.7, color='steelblue')
    ax1.set_xlabel('Principal Component')
    ax1.set_ylabel('Variance Explained (%)')
    ax1.set_title('Eigenvalue Spectrum')
    ax1.axhline(y=40, color='r', linestyle='--', alpha=0.5, label='40% threshold (health target)')
    ax1.legend()
    ax1.grid(True, alpha=0.3)

    # Cumulative variance
    ax2.plot(range(1, n_components + 1), cumsum, 'o-', color='steelblue')
    ax2.axhline(y=90, color='r', linestyle='--', alpha=0.5, label='90% threshold')
    ax2.axhline(y=95, color='orange', linestyle='--', alpha=0.5, label='95% threshold')
    ax2.set_xlabel('Number of Components')
    ax2.set_ylabel('Cumulative Variance (%)')
    ax2.set_title('Cumulative Variance Explained')
    ax2.legend()
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(output_path, dpi=150)
    plt.close()
    print(f"Saved: {output_path}")


def plot_fft_vs_dct_comparison(embeddings: np.ndarray, types: list[str], transforms: list[str],
                                output_path: str = 'fft_vs_dct.png'):
    """PCA scatter plot comparing FFT vs DCT embeddings, colored by transform type."""
    pca = PCA(n_components=2)
    proj = pca.fit_transform(embeddings)

    transforms_arr = np.array(transforms)

    plt.figure(figsize=(14, 10))

    # Get unique trajectory types
    unique_types = sorted(set(types))
    colors = plt.colormaps['tab10'](np.linspace(0, 1, len(unique_types)))
    type_to_color = {t: colors[i] for i, t in enumerate(unique_types)}

    # Plot FFT points (circles)
    fft_mask = transforms_arr == 'FFT'
    for ttype in unique_types:
        mask = fft_mask & (np.array(types) == ttype)
        if np.any(mask):
            plt.scatter(proj[mask, 0], proj[mask, 1],
                       c=[type_to_color[ttype]], marker='o',
                       label=f'{ttype} (FFT)',
                       alpha=0.7, s=100, edgecolors='white', linewidth=1)

    # Plot DCT points (triangles)
    dct_mask = transforms_arr == 'DCT'
    for ttype in unique_types:
        mask = dct_mask & (np.array(types) == ttype)
        if np.any(mask):
            plt.scatter(proj[mask, 0], proj[mask, 1],
                       c=[type_to_color[ttype]], marker='^',
                       label=f'{ttype} (DCT)',
                       alpha=0.7, s=100, edgecolors='white', linewidth=1)

    plt.xlabel(f'PC1 ({pca.explained_variance_ratio_[0]*100:.1f}%)')
    plt.ylabel(f'PC2 ({pca.explained_variance_ratio_[1]*100:.1f}%)')
    plt.title('FFT vs DCT Embeddings in PCA Space\n(circles=FFT, triangles=DCT)')
    plt.legend(loc='center left', bbox_to_anchor=(1, 0.5), fontsize=8, framealpha=0.9)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved: {output_path}")


def plot_fft_dct_embedding_distance(full_embeddings: np.ndarray, types: list[str], transforms: list[str],
                                     output_path: str = 'fft_dct_distance.png'):
    """Bar chart showing L2 distance between FFT and DCT FULL embeddings for each trajectory type.

    Note: Uses full embeddings (including spectral features) to show actual FFT vs DCT differences.
    The compact embedding (24D) doesn't include spectral features and would show 0 distance.
    """
    # Group embeddings by trajectory type
    unique_types = sorted(set(types))
    distances = {}

    for ttype in unique_types:
        fft_embs = []
        dct_embs = []

        for i, (t, tr) in enumerate(zip(types, transforms)):
            if t == ttype:
                if tr == 'FFT':
                    fft_embs.append(full_embeddings[i])
                else:
                    dct_embs.append(full_embeddings[i])

        if fft_embs and dct_embs:
            # Compute mean distance between matched pairs
            fft_arr = np.array(fft_embs)
            dct_arr = np.array(dct_embs)
            n = min(len(fft_arr), len(dct_arr))
            dist = np.mean([np.linalg.norm(fft_arr[i] - dct_arr[i]) for i in range(n)])
            distances[ttype] = dist

    if not distances:
        print("Warning: No matched FFT/DCT pairs found for distance calculation")
        return

    # Create bar chart
    types_sorted = sorted(distances.keys(), key=lambda x: distances[x], reverse=True)
    dists = [distances[t] for t in types_sorted]

    plt.figure(figsize=(12, 6))
    bars = plt.bar(range(len(types_sorted)), dists, color='steelblue', alpha=0.7)

    # Add value labels on bars
    for bar, dist in zip(bars, dists):
        plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.02,
                f'{dist:.2f}', ha='center', va='bottom', fontsize=9)

    plt.xticks(range(len(types_sorted)), types_sorted, rotation=45, ha='right')
    plt.xlabel('Trajectory Type')
    plt.ylabel('L2 Distance (FFT vs DCT Full Embedding)')
    plt.title('Spectral Embedding Distance: FFT vs DCT by Trajectory Type\n(Higher = more different spectral representations)')
    plt.grid(True, alpha=0.3, axis='y')
    plt.tight_layout()
    plt.savefig(output_path, dpi=150)
    plt.close()
    print(f"Saved: {output_path}")


def plot_transform_pca_by_type(embeddings: np.ndarray, types: list[str], transforms: list[str],
                                output_path: str = 'transform_by_type.png'):
    """Grid of PCA plots, one per trajectory type, showing FFT vs DCT clustering."""
    unique_types = sorted(set(types))
    n_types = len(unique_types)

    # Calculate grid dimensions
    n_cols = 4
    n_rows = (n_types + n_cols - 1) // n_cols

    fig, axes = plt.subplots(n_rows, n_cols, figsize=(16, 4 * n_rows))
    axes = axes.flatten()

    # Global PCA
    pca = PCA(n_components=2)
    proj = pca.fit_transform(embeddings)

    for idx, ttype in enumerate(unique_types):
        ax = axes[idx]
        mask = np.array(types) == ttype
        type_proj = proj[mask]
        type_transforms = [transforms[i] for i in range(len(transforms)) if mask[i]]

        fft_mask = np.array(type_transforms) == 'FFT'
        dct_mask = np.array(type_transforms) == 'DCT'

        if np.any(fft_mask):
            ax.scatter(type_proj[fft_mask, 0], type_proj[fft_mask, 1],
                      c='blue', marker='o', label='FFT', alpha=0.7, s=80)
        if np.any(dct_mask):
            ax.scatter(type_proj[dct_mask, 0], type_proj[dct_mask, 1],
                      c='red', marker='^', label='DCT', alpha=0.7, s=80)

        ax.set_title(ttype)
        ax.legend(fontsize=8)
        ax.grid(True, alpha=0.3)

    # Hide empty subplots
    for idx in range(len(unique_types), len(axes)):
        axes[idx].set_visible(False)

    fig.suptitle('FFT vs DCT Embeddings by Trajectory Type', fontsize=14, y=1.02)
    plt.tight_layout()
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved: {output_path}")


def load_mse_data(path: str) -> tuple[list[dict], list[int], list[str]]:
    """Load MSE data from JSON file exported by Rust.

    Returns:
        data_points: list of dicts with trajectory_type, spectral_transform, k_coeffs, rmse
        k_values: list of k_coeffs values tested
        trajectory_types: list of trajectory type names
    """
    with open(path) as f:
        data = json.load(f)

    return data['data_points'], data['k_values'], data['trajectory_types']


def plot_mse_vs_kcoeffs(data_points: list[dict], k_values: list[int],
                         output_path: str = 'mse_vs_k.png'):
    """Line plot showing RMSE vs k_coeffs for each trajectory type, FFT vs DCT."""
    # Organize data by trajectory type and transform
    trajectory_types = sorted(set(dp['trajectory_type'] for dp in data_points))
    n_types = len(trajectory_types)

    # Create subplots grid
    n_cols = 4
    n_rows = (n_types + n_cols - 1) // n_cols

    fig, axes = plt.subplots(n_rows, n_cols, figsize=(16, 4 * n_rows))
    axes = axes.flatten()

    for idx, traj_type in enumerate(trajectory_types):
        ax = axes[idx]

        # Get data for this trajectory type
        fft_data = [(dp['k_coeffs'], dp['rmse']) for dp in data_points
                    if dp['trajectory_type'] == traj_type and dp['spectral_transform'] == 'FFT']
        dct_data = [(dp['k_coeffs'], dp['rmse']) for dp in data_points
                    if dp['trajectory_type'] == traj_type and dp['spectral_transform'] == 'DCT']

        fft_data.sort()
        dct_data.sort()

        fft_k, fft_rmse = zip(*fft_data) if fft_data else ([], [])
        dct_k, dct_rmse = zip(*dct_data) if dct_data else ([], [])

        ax.plot(fft_k, fft_rmse, 'b-o', label='FFT', markersize=6, linewidth=2)
        ax.plot(dct_k, dct_rmse, 'r-^', label='DCT', markersize=6, linewidth=2)

        ax.set_xlabel('k_coeffs')
        ax.set_ylabel('RMSE (m)')
        ax.set_title(traj_type)
        ax.legend(fontsize=8)
        ax.grid(True, alpha=0.3)
        ax.set_yscale('log')

    # Hide empty subplots
    for idx in range(len(trajectory_types), len(axes)):
        axes[idx].set_visible(False)

    fig.suptitle('Reconstruction RMSE vs k_coeffs: FFT vs DCT', fontsize=14, y=1.02)
    plt.tight_layout()
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved: {output_path}")


def plot_mse_heatmap(data_points: list[dict], k_values: list[int],
                     output_path: str = 'mse_heatmap.png'):
    """Heatmap of RMSE values: trajectory type vs k_coeffs, separate for FFT and DCT."""
    trajectory_types = sorted(set(dp['trajectory_type'] for dp in data_points))

    # Create matrices
    fft_matrix = np.zeros((len(trajectory_types), len(k_values)))
    dct_matrix = np.zeros((len(trajectory_types), len(k_values)))

    for dp in data_points:
        row = trajectory_types.index(dp['trajectory_type'])
        col = k_values.index(dp['k_coeffs'])
        if dp['spectral_transform'] == 'FFT':
            fft_matrix[row, col] = dp['rmse']
        else:
            dct_matrix[row, col] = dp['rmse']

    # Use log scale for better visualization
    fft_log = np.log10(fft_matrix + 1e-6)
    dct_log = np.log10(dct_matrix + 1e-6)

    vmin = min(fft_log.min(), dct_log.min())
    vmax = max(fft_log.max(), dct_log.max())

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 8))

    # FFT heatmap
    im1 = ax1.imshow(fft_log, cmap='YlOrRd', aspect='auto', vmin=vmin, vmax=vmax)
    ax1.set_xticks(range(len(k_values)))
    ax1.set_xticklabels(k_values)
    ax1.set_yticks(range(len(trajectory_types)))
    ax1.set_yticklabels(trajectory_types)
    ax1.set_xlabel('k_coeffs')
    ax1.set_ylabel('Trajectory Type')
    ax1.set_title('FFT Reconstruction RMSE (log10)')

    # Add value annotations
    for i in range(len(trajectory_types)):
        for j in range(len(k_values)):
            val = fft_matrix[i, j]
            ax1.text(j, i, f'{val:.2f}', ha='center', va='center', fontsize=7,
                    color='white' if fft_log[i, j] > (vmin + vmax) / 2 else 'black')

    # DCT heatmap
    im2 = ax2.imshow(dct_log, cmap='YlOrRd', aspect='auto', vmin=vmin, vmax=vmax)
    ax2.set_xticks(range(len(k_values)))
    ax2.set_xticklabels(k_values)
    ax2.set_yticks(range(len(trajectory_types)))
    ax2.set_yticklabels(trajectory_types)
    ax2.set_xlabel('k_coeffs')
    ax2.set_ylabel('Trajectory Type')
    ax2.set_title('DCT Reconstruction RMSE (log10)')

    # Add value annotations
    for i in range(len(trajectory_types)):
        for j in range(len(k_values)):
            val = dct_matrix[i, j]
            ax2.text(j, i, f'{val:.2f}', ha='center', va='center', fontsize=7,
                    color='white' if dct_log[i, j] > (vmin + vmax) / 2 else 'black')

    # Add colorbar
    fig.colorbar(im2, ax=[ax1, ax2], label='log10(RMSE)', shrink=0.8)

    plt.suptitle('Reconstruction RMSE Heatmap: FFT vs DCT', fontsize=14)
    plt.tight_layout()
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved: {output_path}")


def plot_mse_fft_vs_dct_comparison(data_points: list[dict], k_values: list[int],
                                    output_path: str = 'mse_fft_dct_diff.png'):
    """Bar chart showing FFT-DCT RMSE difference for each trajectory type at different k values."""
    trajectory_types = sorted(set(dp['trajectory_type'] for dp in data_points))

    # Select a few representative k values
    k_subset = [8, 16, 32, 48]
    k_subset = [k for k in k_subset if k in k_values]

    n_types = len(trajectory_types)
    n_k = len(k_subset)

    x = np.arange(n_types)
    width = 0.8 / n_k

    fig, ax = plt.subplots(figsize=(14, 6))

    colors = plt.colormaps['viridis'](np.linspace(0.2, 0.8, n_k))

    for i, k in enumerate(k_subset):
        diffs = []
        for traj_type in trajectory_types:
            fft_rmse = next((dp['rmse'] for dp in data_points
                           if dp['trajectory_type'] == traj_type
                           and dp['spectral_transform'] == 'FFT'
                           and dp['k_coeffs'] == k), 0)
            dct_rmse = next((dp['rmse'] for dp in data_points
                           if dp['trajectory_type'] == traj_type
                           and dp['spectral_transform'] == 'DCT'
                           and dp['k_coeffs'] == k), 0)
            # Positive = FFT better, Negative = DCT better
            diffs.append(dct_rmse - fft_rmse)

        offset = (i - n_k / 2 + 0.5) * width
        bars = ax.bar(x + offset, diffs, width, label=f'k={k}', color=colors[i], alpha=0.8)

    ax.axhline(y=0, color='black', linestyle='-', linewidth=0.5)
    ax.set_xlabel('Trajectory Type')
    ax.set_ylabel('RMSE Difference (DCT - FFT)')
    ax.set_title('FFT vs DCT RMSE Difference by Trajectory Type\n(Negative = DCT better, Positive = FFT better)')
    ax.set_xticks(x)
    ax.set_xticklabels(trajectory_types, rotation=45, ha='right')
    ax.legend(title='k_coeffs')
    ax.grid(True, alpha=0.3, axis='y')

    plt.tight_layout()
    plt.savefig(output_path, dpi=150)
    plt.close()
    print(f"Saved: {output_path}")


def plot_mse_summary(data_points: list[dict], output_path: str = 'mse_summary.png'):
    """Summary bar chart: average RMSE for FFT vs DCT across all trajectories at k=16."""
    trajectory_types = sorted(set(dp['trajectory_type'] for dp in data_points))

    # Get k=16 data (default)
    k = 16
    fft_rmses = []
    dct_rmses = []

    for traj_type in trajectory_types:
        fft_rmse = next((dp['rmse'] for dp in data_points
                        if dp['trajectory_type'] == traj_type
                        and dp['spectral_transform'] == 'FFT'
                        and dp['k_coeffs'] == k), 0)
        dct_rmse = next((dp['rmse'] for dp in data_points
                        if dp['trajectory_type'] == traj_type
                        and dp['spectral_transform'] == 'DCT'
                        and dp['k_coeffs'] == k), 0)
        fft_rmses.append(fft_rmse)
        dct_rmses.append(dct_rmse)

    x = np.arange(len(trajectory_types))
    width = 0.35

    fig, ax = plt.subplots(figsize=(14, 6))

    bars1 = ax.bar(x - width/2, fft_rmses, width, label='FFT', color='steelblue', alpha=0.8)
    bars2 = ax.bar(x + width/2, dct_rmses, width, label='DCT', color='coral', alpha=0.8)

    ax.set_xlabel('Trajectory Type')
    ax.set_ylabel('RMSE (m)')
    ax.set_title(f'Reconstruction RMSE at k={k}: FFT vs DCT')
    ax.set_xticks(x)
    ax.set_xticklabels(trajectory_types, rotation=45, ha='right')
    ax.legend()
    ax.grid(True, alpha=0.3, axis='y')

    # Add value labels
    for bar in bars1:
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width()/2, height + 0.01,
               f'{height:.2f}', ha='center', va='bottom', fontsize=7, rotation=90)
    for bar in bars2:
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width()/2, height + 0.01,
               f'{height:.2f}', ha='center', va='bottom', fontsize=7, rotation=90)

    plt.tight_layout()
    plt.savefig(output_path, dpi=150)
    plt.close()
    print(f"Saved: {output_path}")


def main():
    parser = argparse.ArgumentParser(
        description='Analyze motion embeddings exported from Rust with PCA and t-SNE',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Example workflow:
  1. Generate embeddings from Rust:
     cargo test --test export_embeddings -- --ignored --nocapture

  2. Analyze the embeddings:
     poetry run python analyze_embeddings.py embeddings.json

  3. View the generated plots:
     open pca_3d.png tsne_3d.png feature_by_type.png
        """
    )
    parser.add_argument('input', help='Path to embeddings JSON file (from Rust export)')
    parser.add_argument('--output-dir', '-o', default='.',
                       help='Output directory for plots')
    parser.add_argument('--perplexity', '-p', type=int, default=30,
                       help='t-SNE perplexity parameter')
    parser.add_argument('--no-tsne', action='store_true',
                       help='Skip t-SNE visualization (faster)')
    parser.add_argument('--mse-data', '-m', default=None,
                       help='Path to MSE data JSON file for reconstruction analysis')

    args = parser.parse_args()

    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    print(f"Loading embeddings from {args.input}...")
    compact, full, labels, types, transforms = load_embeddings(args.input)
    print(f"Loaded {compact.shape[0]} embeddings:")
    print(f"  Compact: {compact.shape[1]} dimensions")
    print(f"  Full (with spectral): {full.shape[1]} dimensions")

    # Print trajectory type summary
    unique_types = sorted(set(types))
    print(f"\nTrajectory types ({len(unique_types)}):")
    for ttype in unique_types:
        count = types.count(ttype)
        print(f"  {ttype}: {count}")

    # Print transform summary
    unique_transforms = sorted(set(transforms))
    print(f"\nSpectral transforms ({len(unique_transforms)}):")
    for tr in unique_transforms:
        count = transforms.count(tr)
        print(f"  {tr}: {count}")

    print("\n=== Variance Analysis (Compact Embedding) ===")
    stats = analyze_variance(compact)
    print(f"  PC1 Variance: {stats['pc1_variance_percent']:.1f}% (target: <40%)")
    print(f"  Effective Dimensionality: {stats['effective_dimensionality']:.1f} (target: >8)")
    print(f"  Max/Min Variance Ratio: {stats['variance_ratio_max_min']:.1f} (target: <50)")
    print(f"  Health Status: {'HEALTHY' if stats['is_healthy'] else 'UNHEALTHY'}")

    print("\n  Feature Group Variances:")
    for name, var in stats['feature_group_variances'].items():
        print(f"    {name:12s}: {var:.4f}")

    print("\n  Eigenvalue Spectrum (top 10):")
    for i, ev in enumerate(stats['eigenvalue_spectrum'][:10]):
        pct = stats['explained_variance_ratio'][i] * 100
        print(f"    PC{i+1:2d}: {ev:.4f} ({pct:.1f}%)")

    print("\nGenerating visualizations...")

    plot_pca(compact, types, str(output_dir / 'pca_3d.png'))
    plot_feature_distributions(compact, str(output_dir / 'feature_dist.png'))
    plot_feature_by_type(compact, types, str(output_dir / 'feature_by_type.png'))
    plot_correlation_matrix(compact, str(output_dir / 'correlation.png'))
    plot_eigenvalue_spectrum(compact, str(output_dir / 'eigenspectrum.png'))

    if not args.no_tsne and compact.shape[0] >= 10:
        plot_tsne(compact, types, args.perplexity, str(output_dir / 'tsne_3d.png'))

    # FFT vs DCT comparison plots (if both transforms present)
    if len(unique_transforms) > 1:
        print("\nGenerating FFT vs DCT comparison plots...")
        plot_fft_vs_dct_comparison(compact, types, transforms,
                                    str(output_dir / 'fft_vs_dct.png'))
        # Use FULL embedding for distance comparison (includes spectral features)
        plot_fft_dct_embedding_distance(full, types, transforms,
                                         str(output_dir / 'fft_dct_distance.png'))
        plot_transform_pca_by_type(compact, types, transforms,
                                    str(output_dir / 'transform_by_type.png'))

    # MSE analysis plots (if MSE data provided)
    if args.mse_data:
        print("\nLoading MSE data and generating reconstruction analysis plots...")
        mse_data_points, k_values, _ = load_mse_data(args.mse_data)
        print(f"  Loaded {len(mse_data_points)} MSE data points for k values: {k_values}")

        plot_mse_vs_kcoeffs(mse_data_points, k_values, str(output_dir / 'mse_vs_k.png'))
        plot_mse_heatmap(mse_data_points, k_values, str(output_dir / 'mse_heatmap.png'))
        plot_mse_fft_vs_dct_comparison(mse_data_points, k_values, str(output_dir / 'mse_fft_dct_diff.png'))
        plot_mse_summary(mse_data_points, str(output_dir / 'mse_summary.png'))

    print("\nDone!")


if __name__ == '__main__':
    main()
